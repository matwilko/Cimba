namespace Cimba.Protocol
{
    using System;
    using System.IO;
    using Cimba.Client;

    internal class NegotiateRequest : Packet
    {
        private static ushort[] supportedDialects = new ushort[]
        {
            0x0202, // SMB 2.002 dialect revision number
            0x0210 // SMB 2.1 dialect revision number
        };

        internal NegotiateRequest(bool requireSigning)
        {
            this.Command = PacketType.Negotiate;
            this.IsRequest = true;
            this.RequireSigning = requireSigning;
            this.MessageId = 0;
            this.SessionId = 0;
            this.Dialects = supportedDialects;
        }

        private NegotiateRequest()
        {
        }

        internal bool RequireSigning { get; set; }

        internal Negotiate_SecurityMode SecurityMode { get; set; }

        internal Guid ClientGuid { get; set; }

        internal ushort[] Dialects { get; set; }

        internal static NegotiateRequest Read(MemoryStream stream)
        {
            // StructureSize (2 bytes)
            if (BitConverterLE.ToUShort(stream) != 36)
            {
                // TODO: Return error packet
                throw new SmbPacketException("Invalid NegotiateRequest");
            }

            NegotiateRequest packet = new NegotiateRequest();

            // DialectCount (2 bytes)
            ushort dialectCount = BitConverterLE.ToUShort(stream);
            if (dialectCount == 0)
            {
                // TODO: Return error packet
                throw new SmbPacketException("Invalid NegotiateRequest");
            }

            // SecurityMode (2 bytes)
            packet.SecurityMode = (Negotiate_SecurityMode)BitConverterLE.ToUShort(stream);

            // Reserved (2 bytes)
            stream.Seek(2, SeekOrigin.Current);

            // Capabilities (4 bytes) - MUST be set to 0 and MUST ignore on reciept
            stream.Seek(4, SeekOrigin.Current);

            // ClientGuid (16 bytes)
            byte[] guidBuffer = new byte[16];
            stream.Read(guidBuffer, 0, 16);
            packet.ClientGuid = new Guid(guidBuffer);

            // ClientStartTime (8 bytes) - MUST NOT be used and MUST be reserved - Client must set to 0, and server must ignore
            stream.Seek(8, SeekOrigin.Current);

            // Dialects (variable)
            ushort[] dialects = new ushort[dialectCount];
            for (int i = 0; i < dialectCount; i++)
            {
                dialects[i] = BitConverterLE.ToUShort(stream);
            }

            packet.Dialects = dialects;

            return packet;
        }

        protected override byte[] Generate()
        {
            byte[] output = new byte[40];

            // StructureSize (2 bytes) - MUST be set to 36, the size of the NEGOTIATE structure. This is regardless of the number of dialects
            BitConverterLE.GetBytes((ushort)36).CopyTo(output, 0);

            // DialectCount (2 bytes) - The number of dialects in the Dialects[] array
            BitConverterLE.GetBytes((ushort)this.Dialects.Length).CopyTo(output, 2);

            // SecurityMode (2 bytes) - Specifies whether signing is enabled, required at the server, or both.
            BitConverterLE.GetBytes((ushort)(this.RequireSigning ? Negotiate_SecurityMode.SigningRequired : Negotiate_SecurityMode.SigningEnabled)).CopyTo(output, 4);

            // Reserved (2 bytes) - MUST NOT be used and MUST be reserved
            BitConverterLE.GetBytes((ushort)0).CopyTo(output, 6);

            // Capabilities (4 bytes) - This field must be set to 0
            BitConverterLE.GetBytes((ushort)0).CopyTo(output, 8);

            // ClientGuid (16 bytes) - MUST be a GUID generated by the client
            SmbClient.ClientGuid.ToByteArray().CopyTo(output, 12);

            // ClientStartTime (8 bytes) - MUST NOT be used and MUST be reserved. MUST set to 0.
            BitConverterLE.GetBytes((ulong)0).CopyTo(output, 28);

            // Dialects (variable) - an array of 16-bit integers specifying the supported dialect revision numbers
            int startindex = 36;
            for (int i = 0; i < this.Dialects.Length; i++)
            {
                BitConverterLE.GetBytes((ushort)this.Dialects[i]).CopyTo(output, startindex);
                startindex += 2;
            }

            return output;
        }
    }
}